
GccApplication1.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000016  00800100  00000cd6  00000d6a  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00000cd6  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          0000063c  00800116  00800116  00000d80  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00000d80  2**0
                  CONTENTS, READONLY
  4 .debug_aranges 000002b0  00000000  00000000  00000db0  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   000033b0  00000000  00000000  00001060  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 00000d17  00000000  00000000  00004410  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   00001fc3  00000000  00000000  00005127  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  00000784  00000000  00000000  000070ec  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    00000fb1  00000000  00000000  00007870  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    00002871  00000000  00000000  00008821  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 000002a0  00000000  00000000  0000b092  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	45 c0       	rjmp	.+138    	; 0x8c <__ctors_end>
   2:	00 00       	nop
   4:	60 c0       	rjmp	.+192    	; 0xc6 <__bad_interrupt>
   6:	00 00       	nop
   8:	5e c0       	rjmp	.+188    	; 0xc6 <__bad_interrupt>
   a:	00 00       	nop
   c:	5c c0       	rjmp	.+184    	; 0xc6 <__bad_interrupt>
   e:	00 00       	nop
  10:	5a c0       	rjmp	.+180    	; 0xc6 <__bad_interrupt>
  12:	00 00       	nop
  14:	58 c0       	rjmp	.+176    	; 0xc6 <__bad_interrupt>
  16:	00 00       	nop
  18:	56 c0       	rjmp	.+172    	; 0xc6 <__bad_interrupt>
  1a:	00 00       	nop
  1c:	54 c0       	rjmp	.+168    	; 0xc6 <__bad_interrupt>
  1e:	00 00       	nop
  20:	52 c0       	rjmp	.+164    	; 0xc6 <__bad_interrupt>
  22:	00 00       	nop
  24:	50 c0       	rjmp	.+160    	; 0xc6 <__bad_interrupt>
  26:	00 00       	nop
  28:	4e c0       	rjmp	.+156    	; 0xc6 <__bad_interrupt>
  2a:	00 00       	nop
  2c:	4c c0       	rjmp	.+152    	; 0xc6 <__bad_interrupt>
  2e:	00 00       	nop
  30:	4a c0       	rjmp	.+148    	; 0xc6 <__bad_interrupt>
  32:	00 00       	nop
  34:	e2 c2       	rjmp	.+1476   	; 0x5fa <__vector_13>
  36:	00 00       	nop
  38:	46 c0       	rjmp	.+140    	; 0xc6 <__bad_interrupt>
  3a:	00 00       	nop
  3c:	44 c0       	rjmp	.+136    	; 0xc6 <__bad_interrupt>
  3e:	00 00       	nop
  40:	42 c0       	rjmp	.+132    	; 0xc6 <__bad_interrupt>
  42:	00 00       	nop
  44:	40 c0       	rjmp	.+128    	; 0xc6 <__bad_interrupt>
  46:	00 00       	nop
  48:	3e c0       	rjmp	.+124    	; 0xc6 <__bad_interrupt>
  4a:	00 00       	nop
  4c:	3c c0       	rjmp	.+120    	; 0xc6 <__bad_interrupt>
  4e:	00 00       	nop
  50:	3a c0       	rjmp	.+116    	; 0xc6 <__bad_interrupt>
  52:	00 00       	nop
  54:	38 c0       	rjmp	.+112    	; 0xc6 <__bad_interrupt>
  56:	00 00       	nop
  58:	36 c0       	rjmp	.+108    	; 0xc6 <__bad_interrupt>
  5a:	00 00       	nop
  5c:	34 c0       	rjmp	.+104    	; 0xc6 <__bad_interrupt>
  5e:	00 00       	nop
  60:	32 c0       	rjmp	.+100    	; 0xc6 <__bad_interrupt>
  62:	00 00       	nop
  64:	30 c0       	rjmp	.+96     	; 0xc6 <__bad_interrupt>
  66:	00 00       	nop
  68:	2e c0       	rjmp	.+92     	; 0xc6 <__bad_interrupt>
  6a:	00 00       	nop
  6c:	2c c0       	rjmp	.+88     	; 0xc6 <__bad_interrupt>
  6e:	00 00       	nop
  70:	2a c0       	rjmp	.+84     	; 0xc6 <__bad_interrupt>
  72:	00 00       	nop
  74:	28 c0       	rjmp	.+80     	; 0xc6 <__bad_interrupt>
  76:	00 00       	nop
  78:	26 c0       	rjmp	.+76     	; 0xc6 <__bad_interrupt>
  7a:	00 00       	nop
  7c:	24 c0       	rjmp	.+72     	; 0xc6 <__bad_interrupt>
  7e:	00 00       	nop
  80:	22 c0       	rjmp	.+68     	; 0xc6 <__bad_interrupt>
  82:	00 00       	nop
  84:	20 c0       	rjmp	.+64     	; 0xc6 <__bad_interrupt>
  86:	00 00       	nop
  88:	1e c0       	rjmp	.+60     	; 0xc6 <__bad_interrupt>
	...

0000008c <__ctors_end>:
  8c:	11 24       	eor	r1, r1
  8e:	1f be       	out	0x3f, r1	; 63
  90:	cf ef       	ldi	r28, 0xFF	; 255
  92:	d0 e4       	ldi	r29, 0x40	; 64
  94:	de bf       	out	0x3e, r29	; 62
  96:	cd bf       	out	0x3d, r28	; 61

00000098 <__do_copy_data>:
  98:	11 e0       	ldi	r17, 0x01	; 1
  9a:	a0 e0       	ldi	r26, 0x00	; 0
  9c:	b1 e0       	ldi	r27, 0x01	; 1
  9e:	e6 ed       	ldi	r30, 0xD6	; 214
  a0:	fc e0       	ldi	r31, 0x0C	; 12
  a2:	00 e0       	ldi	r16, 0x00	; 0
  a4:	0b bf       	out	0x3b, r16	; 59
  a6:	02 c0       	rjmp	.+4      	; 0xac <__do_copy_data+0x14>
  a8:	07 90       	elpm	r0, Z+
  aa:	0d 92       	st	X+, r0
  ac:	a6 31       	cpi	r26, 0x16	; 22
  ae:	b1 07       	cpc	r27, r17
  b0:	d9 f7       	brne	.-10     	; 0xa8 <__do_copy_data+0x10>

000000b2 <__do_clear_bss>:
  b2:	27 e0       	ldi	r18, 0x07	; 7
  b4:	a6 e1       	ldi	r26, 0x16	; 22
  b6:	b1 e0       	ldi	r27, 0x01	; 1
  b8:	01 c0       	rjmp	.+2      	; 0xbc <.do_clear_bss_start>

000000ba <.do_clear_bss_loop>:
  ba:	1d 92       	st	X+, r1

000000bc <.do_clear_bss_start>:
  bc:	a2 35       	cpi	r26, 0x52	; 82
  be:	b2 07       	cpc	r27, r18
  c0:	e1 f7       	brne	.-8      	; 0xba <.do_clear_bss_loop>
  c2:	7a d0       	rcall	.+244    	; 0x1b8 <main>
  c4:	06 c6       	rjmp	.+3084   	; 0xcd2 <_exit>

000000c6 <__bad_interrupt>:
  c6:	9c cf       	rjmp	.-200    	; 0x0 <__vectors>

000000c8 <MASTER_Tick>:
	master_state = INIT;
}

void MASTER_Tick(){
	//Actions
	switch(master_state){
  c8:	80 91 51 07 	lds	r24, 0x0751
  cc:	81 30       	cpi	r24, 0x01	; 1
  ce:	31 f0       	breq	.+12     	; 0xdc <MASTER_Tick+0x14>
  d0:	18 f0       	brcs	.+6      	; 0xd8 <MASTER_Tick+0x10>
  d2:	82 30       	cpi	r24, 0x02	; 2
  d4:	31 f0       	breq	.+12     	; 0xe2 <MASTER_Tick+0x1a>
  d6:	2c c0       	rjmp	.+88     	; 0x130 <MASTER_Tick+0x68>
		case INIT:
			PORTD = 0;
  d8:	1b b8       	out	0x0b, r1	; 11
			break;
  da:	2a c0       	rjmp	.+84     	; 0x130 <MASTER_Tick+0x68>
		case OFF:
			PORTD = 1;
  dc:	81 e0       	ldi	r24, 0x01	; 1
  de:	8b b9       	out	0x0b, r24	; 11
			break;
  e0:	27 c0       	rjmp	.+78     	; 0x130 <MASTER_Tick+0x68>
		case ON:
			counter++;
  e2:	80 91 18 01 	lds	r24, 0x0118
  e6:	8f 5f       	subi	r24, 0xFF	; 255
			if(counter >= 20)
  e8:	84 31       	cpi	r24, 0x14	; 20
  ea:	18 f4       	brcc	.+6      	; 0xf2 <MASTER_Tick+0x2a>
			break;
		case OFF:
			PORTD = 1;
			break;
		case ON:
			counter++;
  ec:	80 93 18 01 	sts	0x0118, r24
  f0:	03 c0       	rjmp	.+6      	; 0xf8 <MASTER_Tick+0x30>
			if(counter >= 20)
			{
				counter = 0;
  f2:	10 92 18 01 	sts	0x0118, r1
				PORTA &= 0xFD;
  f6:	11 98       	cbi	0x02, 1	; 2
			}
			if(~PINC&0x04)
  f8:	32 99       	sbic	0x06, 2	; 6
  fa:	05 c0       	rjmp	.+10     	; 0x106 <MASTER_Tick+0x3e>
			{
				toggle_right = ~toggle_right;
  fc:	80 91 17 01 	lds	r24, 0x0117
 100:	80 95       	com	r24
 102:	80 93 17 01 	sts	0x0117, r24
			}
			if(~PINC&0x08)
 106:	33 99       	sbic	0x06, 3	; 6
 108:	05 c0       	rjmp	.+10     	; 0x114 <MASTER_Tick+0x4c>
			{
				toggle_left = ~toggle_left;
 10a:	80 91 16 01 	lds	r24, 0x0116
 10e:	80 95       	com	r24
 110:	80 93 16 01 	sts	0x0116, r24
			}			
			if(toggle_right)
 114:	80 91 17 01 	lds	r24, 0x0117
 118:	88 23       	and	r24, r24
 11a:	11 f0       	breq	.+4      	; 0x120 <MASTER_Tick+0x58>
			{
				PORTA |= 0x04;
 11c:	12 9a       	sbi	0x02, 2	; 2
 11e:	01 c0       	rjmp	.+2      	; 0x122 <MASTER_Tick+0x5a>
			}
			else
			{
				PORTA &= 0xFB;
 120:	12 98       	cbi	0x02, 2	; 2
			}
			if(toggle_left)
 122:	80 91 16 01 	lds	r24, 0x0116
 126:	88 23       	and	r24, r24
 128:	11 f0       	breq	.+4      	; 0x12e <MASTER_Tick+0x66>
			{
				PORTA |= 0x08;
 12a:	13 9a       	sbi	0x02, 3	; 2
 12c:	01 c0       	rjmp	.+2      	; 0x130 <MASTER_Tick+0x68>
			}
			else
			{
				PORTA &= 0xF7;
 12e:	13 98       	cbi	0x02, 3	; 2
			}
			break;
	}
	//Transitions
	switch(master_state){
 130:	80 91 51 07 	lds	r24, 0x0751
 134:	81 30       	cpi	r24, 0x01	; 1
 136:	41 f0       	breq	.+16     	; 0x148 <MASTER_Tick+0x80>
 138:	18 f0       	brcs	.+6      	; 0x140 <MASTER_Tick+0x78>
 13a:	82 30       	cpi	r24, 0x02	; 2
 13c:	71 f0       	breq	.+28     	; 0x15a <MASTER_Tick+0x92>
 13e:	08 95       	ret
		case INIT:
			master_state = OFF;
 140:	81 e0       	ldi	r24, 0x01	; 1
 142:	80 93 51 07 	sts	0x0751, r24
			break;
 146:	08 95       	ret
		case OFF:
			if(~PINC&0x10)
 148:	34 99       	sbic	0x06, 4	; 6
 14a:	0f c0       	rjmp	.+30     	; 0x16a <MASTER_Tick+0xa2>
			{
				PORTA |= 0x03;
 14c:	82 b1       	in	r24, 0x02	; 2
 14e:	83 60       	ori	r24, 0x03	; 3
 150:	82 b9       	out	0x02, r24	; 2
				master_state = ON;
 152:	82 e0       	ldi	r24, 0x02	; 2
 154:	80 93 51 07 	sts	0x0751, r24
 158:	08 95       	ret
			}
			break;
		case ON:
			if(~PINC&0x01 && ~PINC&0x02)
 15a:	30 99       	sbic	0x06, 0	; 6
 15c:	06 c0       	rjmp	.+12     	; 0x16a <MASTER_Tick+0xa2>
 15e:	31 99       	sbic	0x06, 1	; 6
 160:	04 c0       	rjmp	.+8      	; 0x16a <MASTER_Tick+0xa2>
			{
				PORTA = 0x00;
 162:	12 b8       	out	0x02, r1	; 2
				master_state = OFF;
 164:	81 e0       	ldi	r24, 0x01	; 1
 166:	80 93 51 07 	sts	0x0751, r24
 16a:	08 95       	ret

0000016c <MasterSecTask>:
enum MASTERState {INIT,OFF,ON} master_state;
unsigned char counter = 0;
unsigned char toggle_right = 0x00;
unsigned char toggle_left = 0x00;
void MASTER_Init(){
	master_state = INIT;
 16c:	10 92 51 07 	sts	0x0751, r1
void MasterSecTask()
{
	MASTER_Init();
	for(;;)
	{
		MASTER_Tick();
 170:	ab df       	rcall	.-170    	; 0xc8 <MASTER_Tick>
		vTaskDelay(50);
 172:	82 e3       	ldi	r24, 0x32	; 50
 174:	90 e0       	ldi	r25, 0x00	; 0
 176:	e5 d4       	rcall	.+2506   	; 0xb42 <vTaskDelay>
 178:	fb cf       	rjmp	.-10     	; 0x170 <MasterSecTask+0x4>

0000017a <StartSecPulse>:
	}
}

void StartSecPulse(unsigned portBASE_TYPE Priority)
{
 17a:	af 92       	push	r10
 17c:	bf 92       	push	r11
 17e:	cf 92       	push	r12
 180:	df 92       	push	r13
 182:	ef 92       	push	r14
 184:	ff 92       	push	r15
 186:	0f 93       	push	r16
	xTaskCreate(MasterSecTask, (signed portCHAR *)"MasterSecTask", configMINIMAL_STACK_SIZE, NULL, Priority, NULL );
 188:	a1 2c       	mov	r10, r1
 18a:	b1 2c       	mov	r11, r1
 18c:	c1 2c       	mov	r12, r1
 18e:	d1 2c       	mov	r13, r1
 190:	e1 2c       	mov	r14, r1
 192:	f1 2c       	mov	r15, r1
 194:	08 2f       	mov	r16, r24
 196:	20 e0       	ldi	r18, 0x00	; 0
 198:	30 e0       	ldi	r19, 0x00	; 0
 19a:	45 e5       	ldi	r20, 0x55	; 85
 19c:	50 e0       	ldi	r21, 0x00	; 0
 19e:	62 e0       	ldi	r22, 0x02	; 2
 1a0:	71 e0       	ldi	r23, 0x01	; 1
 1a2:	86 eb       	ldi	r24, 0xB6	; 182
 1a4:	90 e0       	ldi	r25, 0x00	; 0
 1a6:	60 d2       	rcall	.+1216   	; 0x668 <xTaskGenericCreate>
}
 1a8:	0f 91       	pop	r16
 1aa:	ff 90       	pop	r15
 1ac:	ef 90       	pop	r14
 1ae:	df 90       	pop	r13
 1b0:	cf 90       	pop	r12
 1b2:	bf 90       	pop	r11
 1b4:	af 90       	pop	r10
 1b6:	08 95       	ret

000001b8 <main>:

int main(void)
{
	DDRC = 0x00; PORTC = 0xFF;
 1b8:	17 b8       	out	0x07, r1	; 7
 1ba:	8f ef       	ldi	r24, 0xFF	; 255
 1bc:	88 b9       	out	0x08, r24	; 8
	DDRA = 0xFF; PORTA = 0x00;
 1be:	81 b9       	out	0x01, r24	; 1
 1c0:	12 b8       	out	0x02, r1	; 2
	//Start Tasks
	StartSecPulse(1);
 1c2:	81 e0       	ldi	r24, 0x01	; 1
 1c4:	da df       	rcall	.-76     	; 0x17a <StartSecPulse>
	//RunSchedular
	vTaskStartScheduler();
 1c6:	42 d3       	rcall	.+1668   	; 0x84c <vTaskStartScheduler>
	
	return 0;
 1c8:	80 e0       	ldi	r24, 0x00	; 0
 1ca:	90 e0       	ldi	r25, 0x00	; 0
 1cc:	08 95       	ret

000001ce <pvPortMalloc>:

static size_t xNextFreeByte = ( size_t ) 0;
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
 1ce:	cf 93       	push	r28
 1d0:	df 93       	push	r29
 1d2:	ec 01       	movw	r28, r24
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	#endif

	vTaskSuspendAll();
 1d4:	64 d3       	rcall	.+1736   	; 0x89e <vTaskSuspendAll>
	{
		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configTOTAL_HEAP_SIZE ) &&
 1d6:	40 91 19 01 	lds	r20, 0x0119
 1da:	50 91 1a 01 	lds	r21, 0x011A
 1de:	9e 01       	movw	r18, r28
 1e0:	24 0f       	add	r18, r20
 1e2:	35 1f       	adc	r19, r21
 1e4:	2c 3d       	cpi	r18, 0xDC	; 220
 1e6:	85 e0       	ldi	r24, 0x05	; 5
 1e8:	38 07       	cpc	r19, r24
 1ea:	58 f4       	brcc	.+22     	; 0x202 <pvPortMalloc+0x34>
 1ec:	42 17       	cp	r20, r18
 1ee:	53 07       	cpc	r21, r19
 1f0:	58 f4       	brcc	.+22     	; 0x208 <pvPortMalloc+0x3a>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = &( xHeap.ucHeap[ xNextFreeByte ] );
 1f2:	ea 01       	movw	r28, r20
 1f4:	c5 5e       	subi	r28, 0xE5	; 229
 1f6:	de 4f       	sbci	r29, 0xFE	; 254
			xNextFreeByte += xWantedSize;			
 1f8:	30 93 1a 01 	sts	0x011A, r19
 1fc:	20 93 19 01 	sts	0x0119, r18
 200:	05 c0       	rjmp	.+10     	; 0x20c <pvPortMalloc+0x3e>
static size_t xNextFreeByte = ( size_t ) 0;
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
void *pvReturn = NULL; 
 202:	c0 e0       	ldi	r28, 0x00	; 0
 204:	d0 e0       	ldi	r29, 0x00	; 0
 206:	02 c0       	rjmp	.+4      	; 0x20c <pvPortMalloc+0x3e>
 208:	c0 e0       	ldi	r28, 0x00	; 0
 20a:	d0 e0       	ldi	r29, 0x00	; 0
			block. */
			pvReturn = &( xHeap.ucHeap[ xNextFreeByte ] );
			xNextFreeByte += xWantedSize;			
		}	
	}
	xTaskResumeAll();
 20c:	0f d4       	rcall	.+2078   	; 0xa2c <xTaskResumeAll>
		}
	}
	#endif	

	return pvReturn;
}
 20e:	ce 01       	movw	r24, r28
 210:	df 91       	pop	r29
 212:	cf 91       	pop	r28
 214:	08 95       	ret

00000216 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
 216:	08 95       	ret

00000218 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( xList *pxList )
{
 218:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
 21a:	03 96       	adiw	r24, 0x03	; 3
 21c:	92 83       	std	Z+2, r25	; 0x02
 21e:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
 220:	2f ef       	ldi	r18, 0xFF	; 255
 222:	3f ef       	ldi	r19, 0xFF	; 255
 224:	34 83       	std	Z+4, r19	; 0x04
 226:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
 228:	96 83       	std	Z+6, r25	; 0x06
 22a:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
 22c:	90 87       	std	Z+8, r25	; 0x08
 22e:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
 230:	10 82       	st	Z, r1
 232:	08 95       	ret

00000234 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
 234:	fc 01       	movw	r30, r24
 236:	11 86       	std	Z+9, r1	; 0x09
 238:	10 86       	std	Z+8, r1	; 0x08
 23a:	08 95       	ret

0000023c <vListInsertEnd>:
}
/*-----------------------------------------------------------*/

void vListInsertEnd( xList *pxList, xListItem *pxNewListItem )
{
 23c:	cf 93       	push	r28
 23e:	df 93       	push	r29
 240:	fc 01       	movw	r30, r24
 242:	db 01       	movw	r26, r22

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
 244:	21 81       	ldd	r18, Z+1	; 0x01
 246:	32 81       	ldd	r19, Z+2	; 0x02

	pxNewListItem->pxNext = pxIndex->pxNext;
 248:	e9 01       	movw	r28, r18
 24a:	8a 81       	ldd	r24, Y+2	; 0x02
 24c:	9b 81       	ldd	r25, Y+3	; 0x03
 24e:	13 96       	adiw	r26, 0x03	; 3
 250:	9c 93       	st	X, r25
 252:	8e 93       	st	-X, r24
 254:	12 97       	sbiw	r26, 0x02	; 2
	pxNewListItem->pxPrevious = pxList->pxIndex;
 256:	81 81       	ldd	r24, Z+1	; 0x01
 258:	92 81       	ldd	r25, Z+2	; 0x02
 25a:	15 96       	adiw	r26, 0x05	; 5
 25c:	9c 93       	st	X, r25
 25e:	8e 93       	st	-X, r24
 260:	14 97       	sbiw	r26, 0x04	; 4
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
 262:	8a 81       	ldd	r24, Y+2	; 0x02
 264:	9b 81       	ldd	r25, Y+3	; 0x03
 266:	ec 01       	movw	r28, r24
 268:	7d 83       	std	Y+5, r23	; 0x05
 26a:	6c 83       	std	Y+4, r22	; 0x04
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
 26c:	e9 01       	movw	r28, r18
 26e:	7b 83       	std	Y+3, r23	; 0x03
 270:	6a 83       	std	Y+2, r22	; 0x02
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
 272:	72 83       	std	Z+2, r23	; 0x02
 274:	61 83       	std	Z+1, r22	; 0x01

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
 276:	19 96       	adiw	r26, 0x09	; 9
 278:	fc 93       	st	X, r31
 27a:	ee 93       	st	-X, r30
 27c:	18 97       	sbiw	r26, 0x08	; 8

	( pxList->uxNumberOfItems )++;
 27e:	80 81       	ld	r24, Z
 280:	8f 5f       	subi	r24, 0xFF	; 255
 282:	80 83       	st	Z, r24
}
 284:	df 91       	pop	r29
 286:	cf 91       	pop	r28
 288:	08 95       	ret

0000028a <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( xList *pxList, xListItem *pxNewListItem )
{
 28a:	cf 93       	push	r28
 28c:	df 93       	push	r29
 28e:	eb 01       	movw	r28, r22
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
 290:	48 81       	ld	r20, Y
 292:	59 81       	ldd	r21, Y+1	; 0x01
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
 294:	4f 3f       	cpi	r20, 0xFF	; 255
 296:	2f ef       	ldi	r18, 0xFF	; 255
 298:	52 07       	cpc	r21, r18
 29a:	31 f4       	brne	.+12     	; 0x2a8 <vListInsert+0x1e>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
 29c:	dc 01       	movw	r26, r24
 29e:	17 96       	adiw	r26, 0x07	; 7
 2a0:	ed 91       	ld	r30, X+
 2a2:	fc 91       	ld	r31, X
 2a4:	18 97       	sbiw	r26, 0x08	; 8
 2a6:	17 c0       	rjmp	.+46     	; 0x2d6 <vListInsert+0x4c>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/
		
		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
 2a8:	fc 01       	movw	r30, r24
 2aa:	33 96       	adiw	r30, 0x03	; 3
 2ac:	dc 01       	movw	r26, r24
 2ae:	15 96       	adiw	r26, 0x05	; 5
 2b0:	2d 91       	ld	r18, X+
 2b2:	3c 91       	ld	r19, X
 2b4:	16 97       	sbiw	r26, 0x06	; 6
 2b6:	d9 01       	movw	r26, r18
 2b8:	2d 91       	ld	r18, X+
 2ba:	3c 91       	ld	r19, X
 2bc:	42 17       	cp	r20, r18
 2be:	53 07       	cpc	r21, r19
 2c0:	50 f0       	brcs	.+20     	; 0x2d6 <vListInsert+0x4c>
 2c2:	02 80       	ldd	r0, Z+2	; 0x02
 2c4:	f3 81       	ldd	r31, Z+3	; 0x03
 2c6:	e0 2d       	mov	r30, r0
 2c8:	a2 81       	ldd	r26, Z+2	; 0x02
 2ca:	b3 81       	ldd	r27, Z+3	; 0x03
 2cc:	2d 91       	ld	r18, X+
 2ce:	3c 91       	ld	r19, X
 2d0:	42 17       	cp	r20, r18
 2d2:	53 07       	cpc	r21, r19
 2d4:	b0 f7       	brcc	.-20     	; 0x2c2 <vListInsert+0x38>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
 2d6:	a2 81       	ldd	r26, Z+2	; 0x02
 2d8:	b3 81       	ldd	r27, Z+3	; 0x03
 2da:	bb 83       	std	Y+3, r27	; 0x03
 2dc:	aa 83       	std	Y+2, r26	; 0x02
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
 2de:	15 96       	adiw	r26, 0x05	; 5
 2e0:	dc 93       	st	X, r29
 2e2:	ce 93       	st	-X, r28
 2e4:	14 97       	sbiw	r26, 0x04	; 4
	pxNewListItem->pxPrevious = pxIterator;
 2e6:	fd 83       	std	Y+5, r31	; 0x05
 2e8:	ec 83       	std	Y+4, r30	; 0x04
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
 2ea:	d3 83       	std	Z+3, r29	; 0x03
 2ec:	c2 83       	std	Z+2, r28	; 0x02

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
 2ee:	99 87       	std	Y+9, r25	; 0x09
 2f0:	88 87       	std	Y+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
 2f2:	fc 01       	movw	r30, r24
 2f4:	20 81       	ld	r18, Z
 2f6:	2f 5f       	subi	r18, 0xFF	; 255
 2f8:	20 83       	st	Z, r18
}
 2fa:	df 91       	pop	r29
 2fc:	cf 91       	pop	r28
 2fe:	08 95       	ret

00000300 <vListRemove>:
/*-----------------------------------------------------------*/

void vListRemove( xListItem *pxItemToRemove )
{
 300:	fc 01       	movw	r30, r24
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
 302:	a2 81       	ldd	r26, Z+2	; 0x02
 304:	b3 81       	ldd	r27, Z+3	; 0x03
 306:	84 81       	ldd	r24, Z+4	; 0x04
 308:	95 81       	ldd	r25, Z+5	; 0x05
 30a:	15 96       	adiw	r26, 0x05	; 5
 30c:	9c 93       	st	X, r25
 30e:	8e 93       	st	-X, r24
 310:	14 97       	sbiw	r26, 0x04	; 4
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
 312:	a4 81       	ldd	r26, Z+4	; 0x04
 314:	b5 81       	ldd	r27, Z+5	; 0x05
 316:	82 81       	ldd	r24, Z+2	; 0x02
 318:	93 81       	ldd	r25, Z+3	; 0x03
 31a:	13 96       	adiw	r26, 0x03	; 3
 31c:	9c 93       	st	X, r25
 31e:	8e 93       	st	-X, r24
 320:	12 97       	sbiw	r26, 0x02	; 2
	
	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
 322:	a0 85       	ldd	r26, Z+8	; 0x08
 324:	b1 85       	ldd	r27, Z+9	; 0x09

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
 326:	11 96       	adiw	r26, 0x01	; 1
 328:	8d 91       	ld	r24, X+
 32a:	9c 91       	ld	r25, X
 32c:	12 97       	sbiw	r26, 0x02	; 2
 32e:	8e 17       	cp	r24, r30
 330:	9f 07       	cpc	r25, r31
 332:	31 f4       	brne	.+12     	; 0x340 <vListRemove+0x40>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
 334:	84 81       	ldd	r24, Z+4	; 0x04
 336:	95 81       	ldd	r25, Z+5	; 0x05
 338:	12 96       	adiw	r26, 0x02	; 2
 33a:	9c 93       	st	X, r25
 33c:	8e 93       	st	-X, r24
 33e:	11 97       	sbiw	r26, 0x01	; 1
	}

	pxItemToRemove->pvContainer = NULL;
 340:	11 86       	std	Z+9, r1	; 0x09
 342:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
 344:	8c 91       	ld	r24, X
 346:	81 50       	subi	r24, 0x01	; 1
 348:	8c 93       	st	X, r24
 34a:	08 95       	ret

0000034c <pxPortInitialiseStack>:
	return pdTRUE;
}
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
 34c:	31 e1       	ldi	r19, 0x11	; 17
 34e:	fc 01       	movw	r30, r24
 350:	30 83       	st	Z, r19
 352:	31 97       	sbiw	r30, 0x01	; 1
 354:	22 e2       	ldi	r18, 0x22	; 34
 356:	20 83       	st	Z, r18
 358:	31 97       	sbiw	r30, 0x01	; 1
 35a:	a3 e3       	ldi	r26, 0x33	; 51
 35c:	a0 83       	st	Z, r26
 35e:	31 97       	sbiw	r30, 0x01	; 1
 360:	60 83       	st	Z, r22
 362:	31 97       	sbiw	r30, 0x01	; 1
 364:	70 83       	st	Z, r23
 366:	31 97       	sbiw	r30, 0x01	; 1
 368:	10 82       	st	Z, r1
 36a:	31 97       	sbiw	r30, 0x01	; 1
 36c:	60 e8       	ldi	r22, 0x80	; 128
 36e:	60 83       	st	Z, r22
 370:	31 97       	sbiw	r30, 0x01	; 1
 372:	10 82       	st	Z, r1
 374:	31 97       	sbiw	r30, 0x01	; 1
 376:	62 e0       	ldi	r22, 0x02	; 2
 378:	60 83       	st	Z, r22
 37a:	31 97       	sbiw	r30, 0x01	; 1
 37c:	63 e0       	ldi	r22, 0x03	; 3
 37e:	60 83       	st	Z, r22
 380:	31 97       	sbiw	r30, 0x01	; 1
 382:	64 e0       	ldi	r22, 0x04	; 4
 384:	60 83       	st	Z, r22
 386:	31 97       	sbiw	r30, 0x01	; 1
 388:	65 e0       	ldi	r22, 0x05	; 5
 38a:	60 83       	st	Z, r22
 38c:	31 97       	sbiw	r30, 0x01	; 1
 38e:	66 e0       	ldi	r22, 0x06	; 6
 390:	60 83       	st	Z, r22
 392:	31 97       	sbiw	r30, 0x01	; 1
 394:	67 e0       	ldi	r22, 0x07	; 7
 396:	60 83       	st	Z, r22
 398:	31 97       	sbiw	r30, 0x01	; 1
 39a:	68 e0       	ldi	r22, 0x08	; 8
 39c:	60 83       	st	Z, r22
 39e:	31 97       	sbiw	r30, 0x01	; 1
 3a0:	69 e0       	ldi	r22, 0x09	; 9
 3a2:	60 83       	st	Z, r22
 3a4:	31 97       	sbiw	r30, 0x01	; 1
 3a6:	60 e1       	ldi	r22, 0x10	; 16
 3a8:	60 83       	st	Z, r22
 3aa:	31 97       	sbiw	r30, 0x01	; 1
 3ac:	30 83       	st	Z, r19
 3ae:	31 97       	sbiw	r30, 0x01	; 1
 3b0:	32 e1       	ldi	r19, 0x12	; 18
 3b2:	30 83       	st	Z, r19
 3b4:	31 97       	sbiw	r30, 0x01	; 1
 3b6:	33 e1       	ldi	r19, 0x13	; 19
 3b8:	30 83       	st	Z, r19
 3ba:	31 97       	sbiw	r30, 0x01	; 1
 3bc:	34 e1       	ldi	r19, 0x14	; 20
 3be:	30 83       	st	Z, r19
 3c0:	31 97       	sbiw	r30, 0x01	; 1
 3c2:	35 e1       	ldi	r19, 0x15	; 21
 3c4:	30 83       	st	Z, r19
 3c6:	31 97       	sbiw	r30, 0x01	; 1
 3c8:	36 e1       	ldi	r19, 0x16	; 22
 3ca:	30 83       	st	Z, r19
 3cc:	31 97       	sbiw	r30, 0x01	; 1
 3ce:	37 e1       	ldi	r19, 0x17	; 23
 3d0:	30 83       	st	Z, r19
 3d2:	31 97       	sbiw	r30, 0x01	; 1
 3d4:	38 e1       	ldi	r19, 0x18	; 24
 3d6:	30 83       	st	Z, r19
 3d8:	31 97       	sbiw	r30, 0x01	; 1
 3da:	39 e1       	ldi	r19, 0x19	; 25
 3dc:	30 83       	st	Z, r19
 3de:	31 97       	sbiw	r30, 0x01	; 1
 3e0:	30 e2       	ldi	r19, 0x20	; 32
 3e2:	30 83       	st	Z, r19
 3e4:	31 97       	sbiw	r30, 0x01	; 1
 3e6:	31 e2       	ldi	r19, 0x21	; 33
 3e8:	30 83       	st	Z, r19
 3ea:	31 97       	sbiw	r30, 0x01	; 1
 3ec:	20 83       	st	Z, r18
 3ee:	31 97       	sbiw	r30, 0x01	; 1
 3f0:	23 e2       	ldi	r18, 0x23	; 35
 3f2:	20 83       	st	Z, r18
 3f4:	31 97       	sbiw	r30, 0x01	; 1
 3f6:	40 83       	st	Z, r20
 3f8:	31 97       	sbiw	r30, 0x01	; 1
 3fa:	50 83       	st	Z, r21
 3fc:	31 97       	sbiw	r30, 0x01	; 1
 3fe:	26 e2       	ldi	r18, 0x26	; 38
 400:	20 83       	st	Z, r18
 402:	31 97       	sbiw	r30, 0x01	; 1
 404:	27 e2       	ldi	r18, 0x27	; 39
 406:	20 83       	st	Z, r18
 408:	31 97       	sbiw	r30, 0x01	; 1
 40a:	28 e2       	ldi	r18, 0x28	; 40
 40c:	20 83       	st	Z, r18
 40e:	31 97       	sbiw	r30, 0x01	; 1
 410:	29 e2       	ldi	r18, 0x29	; 41
 412:	20 83       	st	Z, r18
 414:	31 97       	sbiw	r30, 0x01	; 1
 416:	20 e3       	ldi	r18, 0x30	; 48
 418:	20 83       	st	Z, r18
 41a:	31 97       	sbiw	r30, 0x01	; 1
 41c:	21 e3       	ldi	r18, 0x31	; 49
 41e:	20 83       	st	Z, r18
 420:	86 97       	sbiw	r24, 0x26	; 38
 422:	08 95       	ret

00000424 <xPortStartScheduler>:
 424:	10 92 89 00 	sts	0x0089, r1
 428:	8c e7       	ldi	r24, 0x7C	; 124
 42a:	80 93 88 00 	sts	0x0088, r24
 42e:	8b e0       	ldi	r24, 0x0B	; 11
 430:	80 93 81 00 	sts	0x0081, r24
 434:	ef e6       	ldi	r30, 0x6F	; 111
 436:	f0 e0       	ldi	r31, 0x00	; 0
 438:	80 81       	ld	r24, Z
 43a:	82 60       	ori	r24, 0x02	; 2
 43c:	80 83       	st	Z, r24
 43e:	a0 91 4f 07 	lds	r26, 0x074F
 442:	b0 91 50 07 	lds	r27, 0x0750
 446:	cd 91       	ld	r28, X+
 448:	cd bf       	out	0x3d, r28	; 61
 44a:	dd 91       	ld	r29, X+
 44c:	de bf       	out	0x3e, r29	; 62
 44e:	ff 91       	pop	r31
 450:	ef 91       	pop	r30
 452:	df 91       	pop	r29
 454:	cf 91       	pop	r28
 456:	bf 91       	pop	r27
 458:	af 91       	pop	r26
 45a:	9f 91       	pop	r25
 45c:	8f 91       	pop	r24
 45e:	7f 91       	pop	r23
 460:	6f 91       	pop	r22
 462:	5f 91       	pop	r21
 464:	4f 91       	pop	r20
 466:	3f 91       	pop	r19
 468:	2f 91       	pop	r18
 46a:	1f 91       	pop	r17
 46c:	0f 91       	pop	r16
 46e:	ff 90       	pop	r15
 470:	ef 90       	pop	r14
 472:	df 90       	pop	r13
 474:	cf 90       	pop	r12
 476:	bf 90       	pop	r11
 478:	af 90       	pop	r10
 47a:	9f 90       	pop	r9
 47c:	8f 90       	pop	r8
 47e:	7f 90       	pop	r7
 480:	6f 90       	pop	r6
 482:	5f 90       	pop	r5
 484:	4f 90       	pop	r4
 486:	3f 90       	pop	r3
 488:	2f 90       	pop	r2
 48a:	1f 90       	pop	r1
 48c:	0f 90       	pop	r0
 48e:	0f be       	out	0x3f, r0	; 63
 490:	0f 90       	pop	r0
 492:	08 95       	ret
 494:	81 e0       	ldi	r24, 0x01	; 1
 496:	08 95       	ret

00000498 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
 498:	0f 92       	push	r0
 49a:	0f b6       	in	r0, 0x3f	; 63
 49c:	f8 94       	cli
 49e:	0f 92       	push	r0
 4a0:	1f 92       	push	r1
 4a2:	11 24       	eor	r1, r1
 4a4:	2f 92       	push	r2
 4a6:	3f 92       	push	r3
 4a8:	4f 92       	push	r4
 4aa:	5f 92       	push	r5
 4ac:	6f 92       	push	r6
 4ae:	7f 92       	push	r7
 4b0:	8f 92       	push	r8
 4b2:	9f 92       	push	r9
 4b4:	af 92       	push	r10
 4b6:	bf 92       	push	r11
 4b8:	cf 92       	push	r12
 4ba:	df 92       	push	r13
 4bc:	ef 92       	push	r14
 4be:	ff 92       	push	r15
 4c0:	0f 93       	push	r16
 4c2:	1f 93       	push	r17
 4c4:	2f 93       	push	r18
 4c6:	3f 93       	push	r19
 4c8:	4f 93       	push	r20
 4ca:	5f 93       	push	r21
 4cc:	6f 93       	push	r22
 4ce:	7f 93       	push	r23
 4d0:	8f 93       	push	r24
 4d2:	9f 93       	push	r25
 4d4:	af 93       	push	r26
 4d6:	bf 93       	push	r27
 4d8:	cf 93       	push	r28
 4da:	df 93       	push	r29
 4dc:	ef 93       	push	r30
 4de:	ff 93       	push	r31
 4e0:	a0 91 4f 07 	lds	r26, 0x074F
 4e4:	b0 91 50 07 	lds	r27, 0x0750
 4e8:	0d b6       	in	r0, 0x3d	; 61
 4ea:	0d 92       	st	X+, r0
 4ec:	0e b6       	in	r0, 0x3e	; 62
 4ee:	0d 92       	st	X+, r0
	vTaskSwitchContext();
 4f0:	7d d3       	rcall	.+1786   	; 0xbec <vTaskSwitchContext>
	portRESTORE_CONTEXT();
 4f2:	a0 91 4f 07 	lds	r26, 0x074F
 4f6:	b0 91 50 07 	lds	r27, 0x0750
 4fa:	cd 91       	ld	r28, X+
 4fc:	cd bf       	out	0x3d, r28	; 61
 4fe:	dd 91       	ld	r29, X+
 500:	de bf       	out	0x3e, r29	; 62
 502:	ff 91       	pop	r31
 504:	ef 91       	pop	r30
 506:	df 91       	pop	r29
 508:	cf 91       	pop	r28
 50a:	bf 91       	pop	r27
 50c:	af 91       	pop	r26
 50e:	9f 91       	pop	r25
 510:	8f 91       	pop	r24
 512:	7f 91       	pop	r23
 514:	6f 91       	pop	r22
 516:	5f 91       	pop	r21
 518:	4f 91       	pop	r20
 51a:	3f 91       	pop	r19
 51c:	2f 91       	pop	r18
 51e:	1f 91       	pop	r17
 520:	0f 91       	pop	r16
 522:	ff 90       	pop	r15
 524:	ef 90       	pop	r14
 526:	df 90       	pop	r13
 528:	cf 90       	pop	r12
 52a:	bf 90       	pop	r11
 52c:	af 90       	pop	r10
 52e:	9f 90       	pop	r9
 530:	8f 90       	pop	r8
 532:	7f 90       	pop	r7
 534:	6f 90       	pop	r6
 536:	5f 90       	pop	r5
 538:	4f 90       	pop	r4
 53a:	3f 90       	pop	r3
 53c:	2f 90       	pop	r2
 53e:	1f 90       	pop	r1
 540:	0f 90       	pop	r0
 542:	0f be       	out	0x3f, r0	; 63
 544:	0f 90       	pop	r0

	asm volatile ( "ret" );
 546:	08 95       	ret

00000548 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
 548:	0f 92       	push	r0
 54a:	0f b6       	in	r0, 0x3f	; 63
 54c:	f8 94       	cli
 54e:	0f 92       	push	r0
 550:	1f 92       	push	r1
 552:	11 24       	eor	r1, r1
 554:	2f 92       	push	r2
 556:	3f 92       	push	r3
 558:	4f 92       	push	r4
 55a:	5f 92       	push	r5
 55c:	6f 92       	push	r6
 55e:	7f 92       	push	r7
 560:	8f 92       	push	r8
 562:	9f 92       	push	r9
 564:	af 92       	push	r10
 566:	bf 92       	push	r11
 568:	cf 92       	push	r12
 56a:	df 92       	push	r13
 56c:	ef 92       	push	r14
 56e:	ff 92       	push	r15
 570:	0f 93       	push	r16
 572:	1f 93       	push	r17
 574:	2f 93       	push	r18
 576:	3f 93       	push	r19
 578:	4f 93       	push	r20
 57a:	5f 93       	push	r21
 57c:	6f 93       	push	r22
 57e:	7f 93       	push	r23
 580:	8f 93       	push	r24
 582:	9f 93       	push	r25
 584:	af 93       	push	r26
 586:	bf 93       	push	r27
 588:	cf 93       	push	r28
 58a:	df 93       	push	r29
 58c:	ef 93       	push	r30
 58e:	ff 93       	push	r31
 590:	a0 91 4f 07 	lds	r26, 0x074F
 594:	b0 91 50 07 	lds	r27, 0x0750
 598:	0d b6       	in	r0, 0x3d	; 61
 59a:	0d 92       	st	X+, r0
 59c:	0e b6       	in	r0, 0x3e	; 62
 59e:	0d 92       	st	X+, r0
	vTaskIncrementTick();
 5a0:	84 d1       	rcall	.+776    	; 0x8aa <vTaskIncrementTick>
	vTaskSwitchContext();
 5a2:	24 d3       	rcall	.+1608   	; 0xbec <vTaskSwitchContext>
	portRESTORE_CONTEXT();
 5a4:	a0 91 4f 07 	lds	r26, 0x074F
 5a8:	b0 91 50 07 	lds	r27, 0x0750
 5ac:	cd 91       	ld	r28, X+
 5ae:	cd bf       	out	0x3d, r28	; 61
 5b0:	dd 91       	ld	r29, X+
 5b2:	de bf       	out	0x3e, r29	; 62
 5b4:	ff 91       	pop	r31
 5b6:	ef 91       	pop	r30
 5b8:	df 91       	pop	r29
 5ba:	cf 91       	pop	r28
 5bc:	bf 91       	pop	r27
 5be:	af 91       	pop	r26
 5c0:	9f 91       	pop	r25
 5c2:	8f 91       	pop	r24
 5c4:	7f 91       	pop	r23
 5c6:	6f 91       	pop	r22
 5c8:	5f 91       	pop	r21
 5ca:	4f 91       	pop	r20
 5cc:	3f 91       	pop	r19
 5ce:	2f 91       	pop	r18
 5d0:	1f 91       	pop	r17
 5d2:	0f 91       	pop	r16
 5d4:	ff 90       	pop	r15
 5d6:	ef 90       	pop	r14
 5d8:	df 90       	pop	r13
 5da:	cf 90       	pop	r12
 5dc:	bf 90       	pop	r11
 5de:	af 90       	pop	r10
 5e0:	9f 90       	pop	r9
 5e2:	8f 90       	pop	r8
 5e4:	7f 90       	pop	r7
 5e6:	6f 90       	pop	r6
 5e8:	5f 90       	pop	r5
 5ea:	4f 90       	pop	r4
 5ec:	3f 90       	pop	r3
 5ee:	2f 90       	pop	r2
 5f0:	1f 90       	pop	r1
 5f2:	0f 90       	pop	r0
 5f4:	0f be       	out	0x3f, r0	; 63
 5f6:	0f 90       	pop	r0

	asm volatile ( "ret" );
 5f8:	08 95       	ret

000005fa <__vector_13>:
	 * count is incremented after the context is saved.
	 */
	void TIMER1_COMPA_vect( void ) __attribute__ ( ( signal, naked ) );
	void TIMER1_COMPA_vect( void )
	{
		vPortYieldFromTick();
 5fa:	a6 df       	rcall	.-180    	; 0x548 <vPortYieldFromTick>
		asm volatile ( "reti" );
 5fc:	18 95       	reti

000005fe <prvAddCurrentTaskToDelayedList>:
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
		{
			portYIELD_WITHIN_API();
		}
	}
 5fe:	cf 93       	push	r28
 600:	df 93       	push	r29
 602:	ec 01       	movw	r28, r24
 604:	e0 91 4f 07 	lds	r30, 0x074F
 608:	f0 91 50 07 	lds	r31, 0x0750
 60c:	93 83       	std	Z+3, r25	; 0x03
 60e:	82 83       	std	Z+2, r24	; 0x02
 610:	80 91 ff 06 	lds	r24, 0x06FF
 614:	90 91 00 07 	lds	r25, 0x0700
 618:	c8 17       	cp	r28, r24
 61a:	d9 07       	cpc	r29, r25
 61c:	60 f4       	brcc	.+24     	; 0x636 <prvAddCurrentTaskToDelayedList+0x38>
 61e:	60 91 4f 07 	lds	r22, 0x074F
 622:	70 91 50 07 	lds	r23, 0x0750
 626:	80 91 15 07 	lds	r24, 0x0715
 62a:	90 91 16 07 	lds	r25, 0x0716
 62e:	6e 5f       	subi	r22, 0xFE	; 254
 630:	7f 4f       	sbci	r23, 0xFF	; 255
 632:	2b de       	rcall	.-938    	; 0x28a <vListInsert>
 634:	16 c0       	rjmp	.+44     	; 0x662 <prvAddCurrentTaskToDelayedList+0x64>
 636:	60 91 4f 07 	lds	r22, 0x074F
 63a:	70 91 50 07 	lds	r23, 0x0750
 63e:	80 91 17 07 	lds	r24, 0x0717
 642:	90 91 18 07 	lds	r25, 0x0718
 646:	6e 5f       	subi	r22, 0xFE	; 254
 648:	7f 4f       	sbci	r23, 0xFF	; 255
 64a:	1f de       	rcall	.-962    	; 0x28a <vListInsert>
 64c:	80 91 00 01 	lds	r24, 0x0100
 650:	90 91 01 01 	lds	r25, 0x0101
 654:	c8 17       	cp	r28, r24
 656:	d9 07       	cpc	r29, r25
 658:	20 f4       	brcc	.+8      	; 0x662 <prvAddCurrentTaskToDelayedList+0x64>
 65a:	d0 93 01 01 	sts	0x0101, r29
 65e:	c0 93 00 01 	sts	0x0100, r28
 662:	df 91       	pop	r29
 664:	cf 91       	pop	r28
 666:	08 95       	ret

00000668 <xTaskGenericCreate>:
 668:	4f 92       	push	r4
 66a:	5f 92       	push	r5
 66c:	6f 92       	push	r6
 66e:	7f 92       	push	r7
 670:	8f 92       	push	r8
 672:	9f 92       	push	r9
 674:	af 92       	push	r10
 676:	bf 92       	push	r11
 678:	cf 92       	push	r12
 67a:	df 92       	push	r13
 67c:	ef 92       	push	r14
 67e:	ff 92       	push	r15
 680:	0f 93       	push	r16
 682:	1f 93       	push	r17
 684:	cf 93       	push	r28
 686:	df 93       	push	r29
 688:	4c 01       	movw	r8, r24
 68a:	3b 01       	movw	r6, r22
 68c:	5a 01       	movw	r10, r20
 68e:	29 01       	movw	r4, r18
 690:	81 e2       	ldi	r24, 0x21	; 33
 692:	90 e0       	ldi	r25, 0x00	; 0
 694:	9c dd       	rcall	.-1224   	; 0x1ce <pvPortMalloc>
 696:	ec 01       	movw	r28, r24
 698:	00 97       	sbiw	r24, 0x00	; 0
 69a:	09 f4       	brne	.+2      	; 0x69e <xTaskGenericCreate+0x36>
 69c:	c5 c0       	rjmp	.+394    	; 0x828 <xTaskGenericCreate+0x1c0>
 69e:	c1 14       	cp	r12, r1
 6a0:	d1 04       	cpc	r13, r1
 6a2:	09 f0       	breq	.+2      	; 0x6a6 <xTaskGenericCreate+0x3e>
 6a4:	bd c0       	rjmp	.+378    	; 0x820 <xTaskGenericCreate+0x1b8>
 6a6:	c5 01       	movw	r24, r10
 6a8:	92 dd       	rcall	.-1244   	; 0x1ce <pvPortMalloc>
 6aa:	98 8f       	std	Y+24, r25	; 0x18
 6ac:	8f 8b       	std	Y+23, r24	; 0x17
 6ae:	00 97       	sbiw	r24, 0x00	; 0
 6b0:	19 f4       	brne	.+6      	; 0x6b8 <xTaskGenericCreate+0x50>
 6b2:	ce 01       	movw	r24, r28
 6b4:	b0 dd       	rcall	.-1184   	; 0x216 <vPortFree>
 6b6:	b8 c0       	rjmp	.+368    	; 0x828 <xTaskGenericCreate+0x1c0>
 6b8:	a5 01       	movw	r20, r10
 6ba:	65 ea       	ldi	r22, 0xA5	; 165
 6bc:	70 e0       	ldi	r23, 0x00	; 0
 6be:	f3 d2       	rcall	.+1510   	; 0xca6 <memset>
 6c0:	81 e0       	ldi	r24, 0x01	; 1
 6c2:	a8 1a       	sub	r10, r24
 6c4:	b1 08       	sbc	r11, r1
 6c6:	8f 89       	ldd	r24, Y+23	; 0x17
 6c8:	98 8d       	ldd	r25, Y+24	; 0x18
 6ca:	a8 0e       	add	r10, r24
 6cc:	b9 1e       	adc	r11, r25
 6ce:	48 e0       	ldi	r20, 0x08	; 8
 6d0:	50 e0       	ldi	r21, 0x00	; 0
 6d2:	b3 01       	movw	r22, r6
 6d4:	ce 01       	movw	r24, r28
 6d6:	49 96       	adiw	r24, 0x19	; 25
 6d8:	ed d2       	rcall	.+1498   	; 0xcb4 <strncpy>
 6da:	18 a2       	std	Y+32, r1	; 0x20
 6dc:	10 2f       	mov	r17, r16
 6de:	04 30       	cpi	r16, 0x04	; 4
 6e0:	08 f0       	brcs	.+2      	; 0x6e4 <xTaskGenericCreate+0x7c>
 6e2:	13 e0       	ldi	r17, 0x03	; 3
 6e4:	1e 8b       	std	Y+22, r17	; 0x16
 6e6:	6e 01       	movw	r12, r28
 6e8:	e2 e0       	ldi	r30, 0x02	; 2
 6ea:	ce 0e       	add	r12, r30
 6ec:	d1 1c       	adc	r13, r1
 6ee:	c6 01       	movw	r24, r12
 6f0:	a1 dd       	rcall	.-1214   	; 0x234 <vListInitialiseItem>
 6f2:	ce 01       	movw	r24, r28
 6f4:	0c 96       	adiw	r24, 0x0c	; 12
 6f6:	9e dd       	rcall	.-1220   	; 0x234 <vListInitialiseItem>
 6f8:	d9 87       	std	Y+9, r29	; 0x09
 6fa:	c8 87       	std	Y+8, r28	; 0x08
 6fc:	84 e0       	ldi	r24, 0x04	; 4
 6fe:	90 e0       	ldi	r25, 0x00	; 0
 700:	81 1b       	sub	r24, r17
 702:	91 09       	sbc	r25, r1
 704:	9d 87       	std	Y+13, r25	; 0x0d
 706:	8c 87       	std	Y+12, r24	; 0x0c
 708:	db 8b       	std	Y+19, r29	; 0x13
 70a:	ca 8b       	std	Y+18, r28	; 0x12
 70c:	a2 01       	movw	r20, r4
 70e:	b4 01       	movw	r22, r8
 710:	c5 01       	movw	r24, r10
 712:	1c de       	rcall	.-968    	; 0x34c <pxPortInitialiseStack>
 714:	99 83       	std	Y+1, r25	; 0x01
 716:	88 83       	st	Y, r24
 718:	e1 14       	cp	r14, r1
 71a:	f1 04       	cpc	r15, r1
 71c:	19 f0       	breq	.+6      	; 0x724 <xTaskGenericCreate+0xbc>
 71e:	f7 01       	movw	r30, r14
 720:	d1 83       	std	Z+1, r29	; 0x01
 722:	c0 83       	st	Z, r28
 724:	0f b6       	in	r0, 0x3f	; 63
 726:	f8 94       	cli
 728:	0f 92       	push	r0
 72a:	80 91 01 07 	lds	r24, 0x0701
 72e:	8f 5f       	subi	r24, 0xFF	; 255
 730:	80 93 01 07 	sts	0x0701, r24
 734:	80 91 4f 07 	lds	r24, 0x074F
 738:	90 91 50 07 	lds	r25, 0x0750
 73c:	89 2b       	or	r24, r25
 73e:	69 f5       	brne	.+90     	; 0x79a <xTaskGenericCreate+0x132>
 740:	d0 93 50 07 	sts	0x0750, r29
 744:	c0 93 4f 07 	sts	0x074F, r28
 748:	80 91 01 07 	lds	r24, 0x0701
 74c:	81 30       	cpi	r24, 0x01	; 1
 74e:	a1 f5       	brne	.+104    	; 0x7b8 <xTaskGenericCreate+0x150>
 750:	8b e2       	ldi	r24, 0x2B	; 43
 752:	97 e0       	ldi	r25, 0x07	; 7
 754:	61 dd       	rcall	.-1342   	; 0x218 <vListInitialise>
 756:	84 e3       	ldi	r24, 0x34	; 52
 758:	97 e0       	ldi	r25, 0x07	; 7
 75a:	5e dd       	rcall	.-1348   	; 0x218 <vListInitialise>
 75c:	8d e3       	ldi	r24, 0x3D	; 61
 75e:	97 e0       	ldi	r25, 0x07	; 7
 760:	5b dd       	rcall	.-1354   	; 0x218 <vListInitialise>
 762:	86 e4       	ldi	r24, 0x46	; 70
 764:	97 e0       	ldi	r25, 0x07	; 7
 766:	58 dd       	rcall	.-1360   	; 0x218 <vListInitialise>
 768:	82 e2       	ldi	r24, 0x22	; 34
 76a:	97 e0       	ldi	r25, 0x07	; 7
 76c:	55 dd       	rcall	.-1366   	; 0x218 <vListInitialise>
 76e:	89 e1       	ldi	r24, 0x19	; 25
 770:	97 e0       	ldi	r25, 0x07	; 7
 772:	52 dd       	rcall	.-1372   	; 0x218 <vListInitialise>
 774:	8c e0       	ldi	r24, 0x0C	; 12
 776:	97 e0       	ldi	r25, 0x07	; 7
 778:	4f dd       	rcall	.-1378   	; 0x218 <vListInitialise>
 77a:	83 e0       	ldi	r24, 0x03	; 3
 77c:	97 e0       	ldi	r25, 0x07	; 7
 77e:	4c dd       	rcall	.-1384   	; 0x218 <vListInitialise>
 780:	82 e2       	ldi	r24, 0x22	; 34
 782:	97 e0       	ldi	r25, 0x07	; 7
 784:	90 93 18 07 	sts	0x0718, r25
 788:	80 93 17 07 	sts	0x0717, r24
 78c:	89 e1       	ldi	r24, 0x19	; 25
 78e:	97 e0       	ldi	r25, 0x07	; 7
 790:	90 93 16 07 	sts	0x0716, r25
 794:	80 93 15 07 	sts	0x0715, r24
 798:	0f c0       	rjmp	.+30     	; 0x7b8 <xTaskGenericCreate+0x150>
 79a:	80 91 fc 06 	lds	r24, 0x06FC
 79e:	81 11       	cpse	r24, r1
 7a0:	0b c0       	rjmp	.+22     	; 0x7b8 <xTaskGenericCreate+0x150>
 7a2:	e0 91 4f 07 	lds	r30, 0x074F
 7a6:	f0 91 50 07 	lds	r31, 0x0750
 7aa:	86 89       	ldd	r24, Z+22	; 0x16
 7ac:	08 17       	cp	r16, r24
 7ae:	20 f0       	brcs	.+8      	; 0x7b8 <xTaskGenericCreate+0x150>
 7b0:	d0 93 50 07 	sts	0x0750, r29
 7b4:	c0 93 4f 07 	sts	0x074F, r28
 7b8:	8e 89       	ldd	r24, Y+22	; 0x16
 7ba:	90 91 fe 06 	lds	r25, 0x06FE
 7be:	98 17       	cp	r25, r24
 7c0:	10 f4       	brcc	.+4      	; 0x7c6 <xTaskGenericCreate+0x15e>
 7c2:	80 93 fe 06 	sts	0x06FE, r24
 7c6:	90 91 f7 06 	lds	r25, 0x06F7
 7ca:	9f 5f       	subi	r25, 0xFF	; 255
 7cc:	90 93 f7 06 	sts	0x06F7, r25
 7d0:	90 91 fd 06 	lds	r25, 0x06FD
 7d4:	98 17       	cp	r25, r24
 7d6:	10 f4       	brcc	.+4      	; 0x7dc <xTaskGenericCreate+0x174>
 7d8:	80 93 fd 06 	sts	0x06FD, r24
 7dc:	90 e0       	ldi	r25, 0x00	; 0
 7de:	9c 01       	movw	r18, r24
 7e0:	22 0f       	add	r18, r18
 7e2:	33 1f       	adc	r19, r19
 7e4:	22 0f       	add	r18, r18
 7e6:	33 1f       	adc	r19, r19
 7e8:	22 0f       	add	r18, r18
 7ea:	33 1f       	adc	r19, r19
 7ec:	82 0f       	add	r24, r18
 7ee:	93 1f       	adc	r25, r19
 7f0:	b6 01       	movw	r22, r12
 7f2:	85 5d       	subi	r24, 0xD5	; 213
 7f4:	98 4f       	sbci	r25, 0xF8	; 248
 7f6:	22 dd       	rcall	.-1468   	; 0x23c <vListInsertEnd>
 7f8:	0f 90       	pop	r0
 7fa:	0f be       	out	0x3f, r0	; 63
 7fc:	80 91 fc 06 	lds	r24, 0x06FC
 800:	88 23       	and	r24, r24
 802:	51 f0       	breq	.+20     	; 0x818 <xTaskGenericCreate+0x1b0>
 804:	e0 91 4f 07 	lds	r30, 0x074F
 808:	f0 91 50 07 	lds	r31, 0x0750
 80c:	86 89       	ldd	r24, Z+22	; 0x16
 80e:	80 17       	cp	r24, r16
 810:	28 f4       	brcc	.+10     	; 0x81c <xTaskGenericCreate+0x1b4>
 812:	42 de       	rcall	.-892    	; 0x498 <vPortYield>
 814:	81 e0       	ldi	r24, 0x01	; 1
 816:	09 c0       	rjmp	.+18     	; 0x82a <xTaskGenericCreate+0x1c2>
 818:	81 e0       	ldi	r24, 0x01	; 1
 81a:	07 c0       	rjmp	.+14     	; 0x82a <xTaskGenericCreate+0x1c2>
 81c:	81 e0       	ldi	r24, 0x01	; 1
 81e:	05 c0       	rjmp	.+10     	; 0x82a <xTaskGenericCreate+0x1c2>
 820:	d8 8e       	std	Y+24, r13	; 0x18
 822:	cf 8a       	std	Y+23, r12	; 0x17
 824:	c6 01       	movw	r24, r12
 826:	48 cf       	rjmp	.-368    	; 0x6b8 <xTaskGenericCreate+0x50>
 828:	8f ef       	ldi	r24, 0xFF	; 255
 82a:	df 91       	pop	r29
 82c:	cf 91       	pop	r28
 82e:	1f 91       	pop	r17
 830:	0f 91       	pop	r16
 832:	ff 90       	pop	r15
 834:	ef 90       	pop	r14
 836:	df 90       	pop	r13
 838:	cf 90       	pop	r12
 83a:	bf 90       	pop	r11
 83c:	af 90       	pop	r10
 83e:	9f 90       	pop	r9
 840:	8f 90       	pop	r8
 842:	7f 90       	pop	r7
 844:	6f 90       	pop	r6
 846:	5f 90       	pop	r5
 848:	4f 90       	pop	r4
 84a:	08 95       	ret

0000084c <vTaskStartScheduler>:
 84c:	af 92       	push	r10
 84e:	bf 92       	push	r11
 850:	cf 92       	push	r12
 852:	df 92       	push	r13
 854:	ef 92       	push	r14
 856:	ff 92       	push	r15
 858:	0f 93       	push	r16
 85a:	a1 2c       	mov	r10, r1
 85c:	b1 2c       	mov	r11, r1
 85e:	c1 2c       	mov	r12, r1
 860:	d1 2c       	mov	r13, r1
 862:	e1 2c       	mov	r14, r1
 864:	f1 2c       	mov	r15, r1
 866:	00 e0       	ldi	r16, 0x00	; 0
 868:	20 e0       	ldi	r18, 0x00	; 0
 86a:	30 e0       	ldi	r19, 0x00	; 0
 86c:	45 e5       	ldi	r20, 0x55	; 85
 86e:	50 e0       	ldi	r21, 0x00	; 0
 870:	60 e1       	ldi	r22, 0x10	; 16
 872:	71 e0       	ldi	r23, 0x01	; 1
 874:	8c eb       	ldi	r24, 0xBC	; 188
 876:	95 e0       	ldi	r25, 0x05	; 5
 878:	f7 de       	rcall	.-530    	; 0x668 <xTaskGenericCreate>
 87a:	81 30       	cpi	r24, 0x01	; 1
 87c:	41 f4       	brne	.+16     	; 0x88e <vTaskStartScheduler+0x42>
 87e:	f8 94       	cli
 880:	80 93 fc 06 	sts	0x06FC, r24
 884:	10 92 00 07 	sts	0x0700, r1
 888:	10 92 ff 06 	sts	0x06FF, r1
 88c:	cb dd       	rcall	.-1130   	; 0x424 <xPortStartScheduler>
 88e:	0f 91       	pop	r16
 890:	ff 90       	pop	r15
 892:	ef 90       	pop	r14
 894:	df 90       	pop	r13
 896:	cf 90       	pop	r12
 898:	bf 90       	pop	r11
 89a:	af 90       	pop	r10
 89c:	08 95       	ret

0000089e <vTaskSuspendAll>:
 89e:	80 91 fb 06 	lds	r24, 0x06FB
 8a2:	8f 5f       	subi	r24, 0xFF	; 255
 8a4:	80 93 fb 06 	sts	0x06FB, r24
 8a8:	08 95       	ret

000008aa <vTaskIncrementTick>:
 8aa:	0f 93       	push	r16
 8ac:	1f 93       	push	r17
 8ae:	cf 93       	push	r28
 8b0:	df 93       	push	r29
 8b2:	80 91 fb 06 	lds	r24, 0x06FB
 8b6:	81 11       	cpse	r24, r1
 8b8:	af c0       	rjmp	.+350    	; 0xa18 <vTaskIncrementTick+0x16e>
 8ba:	80 91 ff 06 	lds	r24, 0x06FF
 8be:	90 91 00 07 	lds	r25, 0x0700
 8c2:	01 96       	adiw	r24, 0x01	; 1
 8c4:	90 93 00 07 	sts	0x0700, r25
 8c8:	80 93 ff 06 	sts	0x06FF, r24
 8cc:	80 91 ff 06 	lds	r24, 0x06FF
 8d0:	90 91 00 07 	lds	r25, 0x0700
 8d4:	89 2b       	or	r24, r25
 8d6:	99 f5       	brne	.+102    	; 0x93e <vTaskIncrementTick+0x94>
 8d8:	80 91 17 07 	lds	r24, 0x0717
 8dc:	90 91 18 07 	lds	r25, 0x0718
 8e0:	20 91 15 07 	lds	r18, 0x0715
 8e4:	30 91 16 07 	lds	r19, 0x0716
 8e8:	30 93 18 07 	sts	0x0718, r19
 8ec:	20 93 17 07 	sts	0x0717, r18
 8f0:	90 93 16 07 	sts	0x0716, r25
 8f4:	80 93 15 07 	sts	0x0715, r24
 8f8:	80 91 f8 06 	lds	r24, 0x06F8
 8fc:	8f 5f       	subi	r24, 0xFF	; 255
 8fe:	80 93 f8 06 	sts	0x06F8, r24
 902:	e0 91 17 07 	lds	r30, 0x0717
 906:	f0 91 18 07 	lds	r31, 0x0718
 90a:	80 81       	ld	r24, Z
 90c:	81 11       	cpse	r24, r1
 90e:	07 c0       	rjmp	.+14     	; 0x91e <vTaskIncrementTick+0x74>
 910:	8f ef       	ldi	r24, 0xFF	; 255
 912:	9f ef       	ldi	r25, 0xFF	; 255
 914:	90 93 01 01 	sts	0x0101, r25
 918:	80 93 00 01 	sts	0x0100, r24
 91c:	10 c0       	rjmp	.+32     	; 0x93e <vTaskIncrementTick+0x94>
 91e:	e0 91 17 07 	lds	r30, 0x0717
 922:	f0 91 18 07 	lds	r31, 0x0718
 926:	05 80       	ldd	r0, Z+5	; 0x05
 928:	f6 81       	ldd	r31, Z+6	; 0x06
 92a:	e0 2d       	mov	r30, r0
 92c:	06 80       	ldd	r0, Z+6	; 0x06
 92e:	f7 81       	ldd	r31, Z+7	; 0x07
 930:	e0 2d       	mov	r30, r0
 932:	82 81       	ldd	r24, Z+2	; 0x02
 934:	93 81       	ldd	r25, Z+3	; 0x03
 936:	90 93 01 01 	sts	0x0101, r25
 93a:	80 93 00 01 	sts	0x0100, r24
 93e:	20 91 ff 06 	lds	r18, 0x06FF
 942:	30 91 00 07 	lds	r19, 0x0700
 946:	80 91 00 01 	lds	r24, 0x0100
 94a:	90 91 01 01 	lds	r25, 0x0101
 94e:	28 17       	cp	r18, r24
 950:	39 07       	cpc	r19, r25
 952:	08 f4       	brcc	.+2      	; 0x956 <vTaskIncrementTick+0xac>
 954:	66 c0       	rjmp	.+204    	; 0xa22 <vTaskIncrementTick+0x178>
 956:	e0 91 17 07 	lds	r30, 0x0717
 95a:	f0 91 18 07 	lds	r31, 0x0718
 95e:	80 81       	ld	r24, Z
 960:	88 23       	and	r24, r24
 962:	99 f0       	breq	.+38     	; 0x98a <vTaskIncrementTick+0xe0>
 964:	e0 91 17 07 	lds	r30, 0x0717
 968:	f0 91 18 07 	lds	r31, 0x0718
 96c:	05 80       	ldd	r0, Z+5	; 0x05
 96e:	f6 81       	ldd	r31, Z+6	; 0x06
 970:	e0 2d       	mov	r30, r0
 972:	c6 81       	ldd	r28, Z+6	; 0x06
 974:	d7 81       	ldd	r29, Z+7	; 0x07
 976:	8a 81       	ldd	r24, Y+2	; 0x02
 978:	9b 81       	ldd	r25, Y+3	; 0x03
 97a:	20 91 ff 06 	lds	r18, 0x06FF
 97e:	30 91 00 07 	lds	r19, 0x0700
 982:	28 17       	cp	r18, r24
 984:	39 07       	cpc	r19, r25
 986:	f8 f4       	brcc	.+62     	; 0x9c6 <vTaskIncrementTick+0x11c>
 988:	19 c0       	rjmp	.+50     	; 0x9bc <vTaskIncrementTick+0x112>
 98a:	8f ef       	ldi	r24, 0xFF	; 255
 98c:	9f ef       	ldi	r25, 0xFF	; 255
 98e:	90 93 01 01 	sts	0x0101, r25
 992:	80 93 00 01 	sts	0x0100, r24
 996:	45 c0       	rjmp	.+138    	; 0xa22 <vTaskIncrementTick+0x178>
 998:	e0 91 17 07 	lds	r30, 0x0717
 99c:	f0 91 18 07 	lds	r31, 0x0718
 9a0:	05 80       	ldd	r0, Z+5	; 0x05
 9a2:	f6 81       	ldd	r31, Z+6	; 0x06
 9a4:	e0 2d       	mov	r30, r0
 9a6:	c6 81       	ldd	r28, Z+6	; 0x06
 9a8:	d7 81       	ldd	r29, Z+7	; 0x07
 9aa:	8a 81       	ldd	r24, Y+2	; 0x02
 9ac:	9b 81       	ldd	r25, Y+3	; 0x03
 9ae:	20 91 ff 06 	lds	r18, 0x06FF
 9b2:	30 91 00 07 	lds	r19, 0x0700
 9b6:	28 17       	cp	r18, r24
 9b8:	39 07       	cpc	r19, r25
 9ba:	28 f4       	brcc	.+10     	; 0x9c6 <vTaskIncrementTick+0x11c>
 9bc:	90 93 01 01 	sts	0x0101, r25
 9c0:	80 93 00 01 	sts	0x0100, r24
 9c4:	2e c0       	rjmp	.+92     	; 0xa22 <vTaskIncrementTick+0x178>
 9c6:	8e 01       	movw	r16, r28
 9c8:	0e 5f       	subi	r16, 0xFE	; 254
 9ca:	1f 4f       	sbci	r17, 0xFF	; 255
 9cc:	c8 01       	movw	r24, r16
 9ce:	98 dc       	rcall	.-1744   	; 0x300 <vListRemove>
 9d0:	8c 89       	ldd	r24, Y+20	; 0x14
 9d2:	9d 89       	ldd	r25, Y+21	; 0x15
 9d4:	89 2b       	or	r24, r25
 9d6:	19 f0       	breq	.+6      	; 0x9de <vTaskIncrementTick+0x134>
 9d8:	ce 01       	movw	r24, r28
 9da:	0c 96       	adiw	r24, 0x0c	; 12
 9dc:	91 dc       	rcall	.-1758   	; 0x300 <vListRemove>
 9de:	8e 89       	ldd	r24, Y+22	; 0x16
 9e0:	90 91 fd 06 	lds	r25, 0x06FD
 9e4:	98 17       	cp	r25, r24
 9e6:	10 f4       	brcc	.+4      	; 0x9ec <vTaskIncrementTick+0x142>
 9e8:	80 93 fd 06 	sts	0x06FD, r24
 9ec:	90 e0       	ldi	r25, 0x00	; 0
 9ee:	9c 01       	movw	r18, r24
 9f0:	22 0f       	add	r18, r18
 9f2:	33 1f       	adc	r19, r19
 9f4:	22 0f       	add	r18, r18
 9f6:	33 1f       	adc	r19, r19
 9f8:	22 0f       	add	r18, r18
 9fa:	33 1f       	adc	r19, r19
 9fc:	82 0f       	add	r24, r18
 9fe:	93 1f       	adc	r25, r19
 a00:	b8 01       	movw	r22, r16
 a02:	85 5d       	subi	r24, 0xD5	; 213
 a04:	98 4f       	sbci	r25, 0xF8	; 248
 a06:	1a dc       	rcall	.-1996   	; 0x23c <vListInsertEnd>
 a08:	e0 91 17 07 	lds	r30, 0x0717
 a0c:	f0 91 18 07 	lds	r31, 0x0718
 a10:	80 81       	ld	r24, Z
 a12:	81 11       	cpse	r24, r1
 a14:	c1 cf       	rjmp	.-126    	; 0x998 <vTaskIncrementTick+0xee>
 a16:	b9 cf       	rjmp	.-142    	; 0x98a <vTaskIncrementTick+0xe0>
 a18:	80 91 fa 06 	lds	r24, 0x06FA
 a1c:	8f 5f       	subi	r24, 0xFF	; 255
 a1e:	80 93 fa 06 	sts	0x06FA, r24
 a22:	df 91       	pop	r29
 a24:	cf 91       	pop	r28
 a26:	1f 91       	pop	r17
 a28:	0f 91       	pop	r16
 a2a:	08 95       	ret

00000a2c <xTaskResumeAll>:
 a2c:	af 92       	push	r10
 a2e:	bf 92       	push	r11
 a30:	cf 92       	push	r12
 a32:	df 92       	push	r13
 a34:	ef 92       	push	r14
 a36:	ff 92       	push	r15
 a38:	0f 93       	push	r16
 a3a:	1f 93       	push	r17
 a3c:	cf 93       	push	r28
 a3e:	df 93       	push	r29
 a40:	0f b6       	in	r0, 0x3f	; 63
 a42:	f8 94       	cli
 a44:	0f 92       	push	r0
 a46:	80 91 fb 06 	lds	r24, 0x06FB
 a4a:	81 50       	subi	r24, 0x01	; 1
 a4c:	80 93 fb 06 	sts	0x06FB, r24
 a50:	80 91 fb 06 	lds	r24, 0x06FB
 a54:	81 11       	cpse	r24, r1
 a56:	63 c0       	rjmp	.+198    	; 0xb1e <xTaskResumeAll+0xf2>
 a58:	80 91 01 07 	lds	r24, 0x0701
 a5c:	88 23       	and	r24, r24
 a5e:	09 f4       	brne	.+2      	; 0xa62 <xTaskResumeAll+0x36>
 a60:	60 c0       	rjmp	.+192    	; 0xb22 <xTaskResumeAll+0xf6>
 a62:	b1 2c       	mov	r11, r1
 a64:	0f 2e       	mov	r0, r31
 a66:	fc e0       	ldi	r31, 0x0C	; 12
 a68:	ef 2e       	mov	r14, r31
 a6a:	f7 e0       	ldi	r31, 0x07	; 7
 a6c:	ff 2e       	mov	r15, r31
 a6e:	f0 2d       	mov	r31, r0
 a70:	0f 2e       	mov	r0, r31
 a72:	f1 e1       	ldi	r31, 0x11	; 17
 a74:	cf 2e       	mov	r12, r31
 a76:	f7 e0       	ldi	r31, 0x07	; 7
 a78:	df 2e       	mov	r13, r31
 a7a:	f0 2d       	mov	r31, r0
 a7c:	aa 24       	eor	r10, r10
 a7e:	a3 94       	inc	r10
 a80:	2b c0       	rjmp	.+86     	; 0xad8 <xTaskResumeAll+0xac>
 a82:	d6 01       	movw	r26, r12
 a84:	ed 91       	ld	r30, X+
 a86:	fc 91       	ld	r31, X
 a88:	c6 81       	ldd	r28, Z+6	; 0x06
 a8a:	d7 81       	ldd	r29, Z+7	; 0x07
 a8c:	ce 01       	movw	r24, r28
 a8e:	0c 96       	adiw	r24, 0x0c	; 12
 a90:	37 dc       	rcall	.-1938   	; 0x300 <vListRemove>
 a92:	8e 01       	movw	r16, r28
 a94:	0e 5f       	subi	r16, 0xFE	; 254
 a96:	1f 4f       	sbci	r17, 0xFF	; 255
 a98:	c8 01       	movw	r24, r16
 a9a:	32 dc       	rcall	.-1948   	; 0x300 <vListRemove>
 a9c:	8e 89       	ldd	r24, Y+22	; 0x16
 a9e:	90 91 fd 06 	lds	r25, 0x06FD
 aa2:	98 17       	cp	r25, r24
 aa4:	10 f4       	brcc	.+4      	; 0xaaa <xTaskResumeAll+0x7e>
 aa6:	80 93 fd 06 	sts	0x06FD, r24
 aaa:	90 e0       	ldi	r25, 0x00	; 0
 aac:	9c 01       	movw	r18, r24
 aae:	22 0f       	add	r18, r18
 ab0:	33 1f       	adc	r19, r19
 ab2:	22 0f       	add	r18, r18
 ab4:	33 1f       	adc	r19, r19
 ab6:	22 0f       	add	r18, r18
 ab8:	33 1f       	adc	r19, r19
 aba:	82 0f       	add	r24, r18
 abc:	93 1f       	adc	r25, r19
 abe:	b8 01       	movw	r22, r16
 ac0:	85 5d       	subi	r24, 0xD5	; 213
 ac2:	98 4f       	sbci	r25, 0xF8	; 248
 ac4:	bb db       	rcall	.-2186   	; 0x23c <vListInsertEnd>
 ac6:	e0 91 4f 07 	lds	r30, 0x074F
 aca:	f0 91 50 07 	lds	r31, 0x0750
 ace:	9e 89       	ldd	r25, Y+22	; 0x16
 ad0:	86 89       	ldd	r24, Z+22	; 0x16
 ad2:	98 17       	cp	r25, r24
 ad4:	08 f0       	brcs	.+2      	; 0xad8 <xTaskResumeAll+0xac>
 ad6:	ba 2c       	mov	r11, r10
 ad8:	f7 01       	movw	r30, r14
 ada:	80 81       	ld	r24, Z
 adc:	81 11       	cpse	r24, r1
 ade:	d1 cf       	rjmp	.-94     	; 0xa82 <xTaskResumeAll+0x56>
 ae0:	80 91 fa 06 	lds	r24, 0x06FA
 ae4:	88 23       	and	r24, r24
 ae6:	79 f0       	breq	.+30     	; 0xb06 <xTaskResumeAll+0xda>
 ae8:	80 91 fa 06 	lds	r24, 0x06FA
 aec:	88 23       	and	r24, r24
 aee:	91 f0       	breq	.+36     	; 0xb14 <xTaskResumeAll+0xe8>
 af0:	dc de       	rcall	.-584    	; 0x8aa <vTaskIncrementTick>
 af2:	80 91 fa 06 	lds	r24, 0x06FA
 af6:	81 50       	subi	r24, 0x01	; 1
 af8:	80 93 fa 06 	sts	0x06FA, r24
 afc:	80 91 fa 06 	lds	r24, 0x06FA
 b00:	81 11       	cpse	r24, r1
 b02:	f6 cf       	rjmp	.-20     	; 0xaf0 <xTaskResumeAll+0xc4>
 b04:	07 c0       	rjmp	.+14     	; 0xb14 <xTaskResumeAll+0xe8>
 b06:	f1 e0       	ldi	r31, 0x01	; 1
 b08:	bf 16       	cp	r11, r31
 b0a:	21 f0       	breq	.+8      	; 0xb14 <xTaskResumeAll+0xe8>
 b0c:	80 91 f9 06 	lds	r24, 0x06F9
 b10:	81 30       	cpi	r24, 0x01	; 1
 b12:	49 f4       	brne	.+18     	; 0xb26 <xTaskResumeAll+0xfa>
 b14:	10 92 f9 06 	sts	0x06F9, r1
 b18:	bf dc       	rcall	.-1666   	; 0x498 <vPortYield>
 b1a:	81 e0       	ldi	r24, 0x01	; 1
 b1c:	05 c0       	rjmp	.+10     	; 0xb28 <xTaskResumeAll+0xfc>
 b1e:	80 e0       	ldi	r24, 0x00	; 0
 b20:	03 c0       	rjmp	.+6      	; 0xb28 <xTaskResumeAll+0xfc>
 b22:	80 e0       	ldi	r24, 0x00	; 0
 b24:	01 c0       	rjmp	.+2      	; 0xb28 <xTaskResumeAll+0xfc>
 b26:	80 e0       	ldi	r24, 0x00	; 0
 b28:	0f 90       	pop	r0
 b2a:	0f be       	out	0x3f, r0	; 63
 b2c:	df 91       	pop	r29
 b2e:	cf 91       	pop	r28
 b30:	1f 91       	pop	r17
 b32:	0f 91       	pop	r16
 b34:	ff 90       	pop	r15
 b36:	ef 90       	pop	r14
 b38:	df 90       	pop	r13
 b3a:	cf 90       	pop	r12
 b3c:	bf 90       	pop	r11
 b3e:	af 90       	pop	r10
 b40:	08 95       	ret

00000b42 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( portTickType xTicksToDelay )
	{
 b42:	cf 93       	push	r28
 b44:	df 93       	push	r29
 b46:	ec 01       	movw	r28, r24
	portTickType xTimeToWake;
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( portTickType ) 0U )
 b48:	00 97       	sbiw	r24, 0x00	; 0
 b4a:	91 f0       	breq	.+36     	; 0xb70 <vTaskDelay+0x2e>
		{
			vTaskSuspendAll();
 b4c:	a8 de       	rcall	.-688    	; 0x89e <vTaskSuspendAll>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
 b4e:	80 91 ff 06 	lds	r24, 0x06FF
 b52:	90 91 00 07 	lds	r25, 0x0700
 b56:	c8 0f       	add	r28, r24
 b58:	d9 1f       	adc	r29, r25

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
 b5a:	80 91 4f 07 	lds	r24, 0x074F
 b5e:	90 91 50 07 	lds	r25, 0x0750
 b62:	02 96       	adiw	r24, 0x02	; 2
 b64:	cd db       	rcall	.-2150   	; 0x300 <vListRemove>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
 b66:	ce 01       	movw	r24, r28
 b68:	4a dd       	rcall	.-1388   	; 0x5fe <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
 b6a:	60 df       	rcall	.-320    	; 0xa2c <xTaskResumeAll>
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
 b6c:	81 11       	cpse	r24, r1
 b6e:	01 c0       	rjmp	.+2      	; 0xb72 <vTaskDelay+0x30>
		{
			portYIELD_WITHIN_API();
 b70:	93 dc       	rcall	.-1754   	; 0x498 <vPortYield>
		}
	}
 b72:	df 91       	pop	r29
 b74:	cf 91       	pop	r28
 b76:	08 95       	ret

00000b78 <prvIdleTask>:
		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0U )
		{
			vTaskSuspendAll();
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
 b78:	0f 2e       	mov	r0, r31
 b7a:	f3 e0       	ldi	r31, 0x03	; 3
 b7c:	ef 2e       	mov	r14, r31
 b7e:	f7 e0       	ldi	r31, 0x07	; 7
 b80:	ff 2e       	mov	r15, r31
 b82:	f0 2d       	mov	r31, r0
			{
				tskTCB *pxTCB;

				taskENTER_CRITICAL();
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
 b84:	0f 2e       	mov	r0, r31
 b86:	f8 e0       	ldi	r31, 0x08	; 8
 b88:	cf 2e       	mov	r12, r31
 b8a:	f7 e0       	ldi	r31, 0x07	; 7
 b8c:	df 2e       	mov	r13, r31
 b8e:	f0 2d       	mov	r31, r0

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
 b90:	cb e2       	ldi	r28, 0x2B	; 43
 b92:	d7 e0       	ldi	r29, 0x07	; 7
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0U )
 b94:	80 91 02 07 	lds	r24, 0x0702
 b98:	88 23       	and	r24, r24
 b9a:	19 f1       	breq	.+70     	; 0xbe2 <prvIdleTask+0x6a>
		{
			vTaskSuspendAll();
 b9c:	80 de       	rcall	.-768    	; 0x89e <vTaskSuspendAll>
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
 b9e:	d7 01       	movw	r26, r14
 ba0:	1c 91       	ld	r17, X
			xTaskResumeAll();
 ba2:	44 df       	rcall	.-376    	; 0xa2c <xTaskResumeAll>

			if( xListIsEmpty == pdFALSE )
 ba4:	11 23       	and	r17, r17
 ba6:	e9 f0       	breq	.+58     	; 0xbe2 <prvIdleTask+0x6a>
			{
				tskTCB *pxTCB;

				taskENTER_CRITICAL();
 ba8:	0f b6       	in	r0, 0x3f	; 63
 baa:	f8 94       	cli
 bac:	0f 92       	push	r0
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
 bae:	d6 01       	movw	r26, r12
 bb0:	ed 91       	ld	r30, X+
 bb2:	fc 91       	ld	r31, X
 bb4:	06 81       	ldd	r16, Z+6	; 0x06
 bb6:	17 81       	ldd	r17, Z+7	; 0x07
					vListRemove( &( pxTCB->xGenericListItem ) );
 bb8:	c8 01       	movw	r24, r16
 bba:	02 96       	adiw	r24, 0x02	; 2
 bbc:	a1 db       	rcall	.-2238   	; 0x300 <vListRemove>
					--uxCurrentNumberOfTasks;
 bbe:	80 91 01 07 	lds	r24, 0x0701
 bc2:	81 50       	subi	r24, 0x01	; 1
 bc4:	80 93 01 07 	sts	0x0701, r24
					--uxTasksDeleted;
 bc8:	80 91 02 07 	lds	r24, 0x0702
 bcc:	81 50       	subi	r24, 0x01	; 1
 bce:	80 93 02 07 	sts	0x0702, r24
				}
				taskEXIT_CRITICAL();
 bd2:	0f 90       	pop	r0
 bd4:	0f be       	out	0x3f, r0	; 63
		want to allocate and clean RAM statically. */
		portCLEAN_UP_TCB( pxTCB );

		/* Free up the memory allocated by the scheduler for the task.  It is up to
		the task to free any memory allocated at the application level. */
		vPortFreeAligned( pxTCB->pxStack );
 bd6:	f8 01       	movw	r30, r16
 bd8:	87 89       	ldd	r24, Z+23	; 0x17
 bda:	90 8d       	ldd	r25, Z+24	; 0x18
 bdc:	1c db       	rcall	.-2504   	; 0x216 <vPortFree>
		vPortFree( pxTCB );
 bde:	c8 01       	movw	r24, r16
 be0:	1a db       	rcall	.-2508   	; 0x216 <vPortFree>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
 be2:	88 81       	ld	r24, Y
 be4:	82 30       	cpi	r24, 0x02	; 2
 be6:	b0 f2       	brcs	.-84     	; 0xb94 <prvIdleTask+0x1c>
			{
				taskYIELD();
 be8:	57 dc       	rcall	.-1874   	; 0x498 <vPortYield>
 bea:	d4 cf       	rjmp	.-88     	; 0xb94 <prvIdleTask+0x1c>

00000bec <vTaskSwitchContext>:
#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
 bec:	80 91 fb 06 	lds	r24, 0x06FB
 bf0:	81 11       	cpse	r24, r1
 bf2:	13 c0       	rjmp	.+38     	; 0xc1a <vTaskSwitchContext+0x2e>
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
 bf4:	80 91 fd 06 	lds	r24, 0x06FD
 bf8:	90 e0       	ldi	r25, 0x00	; 0
 bfa:	fc 01       	movw	r30, r24
 bfc:	ee 0f       	add	r30, r30
 bfe:	ff 1f       	adc	r31, r31
 c00:	ee 0f       	add	r30, r30
 c02:	ff 1f       	adc	r31, r31
 c04:	ee 0f       	add	r30, r30
 c06:	ff 1f       	adc	r31, r31
 c08:	8e 0f       	add	r24, r30
 c0a:	9f 1f       	adc	r25, r31
 c0c:	fc 01       	movw	r30, r24
 c0e:	e5 5d       	subi	r30, 0xD5	; 213
 c10:	f8 4f       	sbci	r31, 0xF8	; 248
 c12:	80 81       	ld	r24, Z
 c14:	88 23       	and	r24, r24
 c16:	29 f0       	breq	.+10     	; 0xc22 <vTaskSwitchContext+0x36>
 c18:	1b c0       	rjmp	.+54     	; 0xc50 <vTaskSwitchContext+0x64>
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
 c1a:	81 e0       	ldi	r24, 0x01	; 1
 c1c:	80 93 f9 06 	sts	0x06F9, r24
 c20:	08 95       	ret
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
 c22:	80 91 fd 06 	lds	r24, 0x06FD
 c26:	81 50       	subi	r24, 0x01	; 1
 c28:	80 93 fd 06 	sts	0x06FD, r24
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
 c2c:	80 91 fd 06 	lds	r24, 0x06FD
 c30:	90 e0       	ldi	r25, 0x00	; 0
 c32:	fc 01       	movw	r30, r24
 c34:	ee 0f       	add	r30, r30
 c36:	ff 1f       	adc	r31, r31
 c38:	ee 0f       	add	r30, r30
 c3a:	ff 1f       	adc	r31, r31
 c3c:	ee 0f       	add	r30, r30
 c3e:	ff 1f       	adc	r31, r31
 c40:	8e 0f       	add	r24, r30
 c42:	9f 1f       	adc	r25, r31
 c44:	fc 01       	movw	r30, r24
 c46:	e5 5d       	subi	r30, 0xD5	; 213
 c48:	f8 4f       	sbci	r31, 0xF8	; 248
 c4a:	80 81       	ld	r24, Z
 c4c:	88 23       	and	r24, r24
 c4e:	49 f3       	breq	.-46     	; 0xc22 <vTaskSwitchContext+0x36>
			--uxTopReadyPriority;
		}
	
		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
 c50:	e0 91 fd 06 	lds	r30, 0x06FD
 c54:	f0 e0       	ldi	r31, 0x00	; 0
 c56:	cf 01       	movw	r24, r30
 c58:	88 0f       	add	r24, r24
 c5a:	99 1f       	adc	r25, r25
 c5c:	88 0f       	add	r24, r24
 c5e:	99 1f       	adc	r25, r25
 c60:	88 0f       	add	r24, r24
 c62:	99 1f       	adc	r25, r25
 c64:	e8 0f       	add	r30, r24
 c66:	f9 1f       	adc	r31, r25
 c68:	e5 5d       	subi	r30, 0xD5	; 213
 c6a:	f8 4f       	sbci	r31, 0xF8	; 248
 c6c:	a1 81       	ldd	r26, Z+1	; 0x01
 c6e:	b2 81       	ldd	r27, Z+2	; 0x02
 c70:	12 96       	adiw	r26, 0x02	; 2
 c72:	0d 90       	ld	r0, X+
 c74:	bc 91       	ld	r27, X
 c76:	a0 2d       	mov	r26, r0
 c78:	b2 83       	std	Z+2, r27	; 0x02
 c7a:	a1 83       	std	Z+1, r26	; 0x01
 c7c:	cf 01       	movw	r24, r30
 c7e:	03 96       	adiw	r24, 0x03	; 3
 c80:	a8 17       	cp	r26, r24
 c82:	b9 07       	cpc	r27, r25
 c84:	31 f4       	brne	.+12     	; 0xc92 <vTaskSwitchContext+0xa6>
 c86:	12 96       	adiw	r26, 0x02	; 2
 c88:	8d 91       	ld	r24, X+
 c8a:	9c 91       	ld	r25, X
 c8c:	13 97       	sbiw	r26, 0x03	; 3
 c8e:	92 83       	std	Z+2, r25	; 0x02
 c90:	81 83       	std	Z+1, r24	; 0x01
 c92:	01 80       	ldd	r0, Z+1	; 0x01
 c94:	f2 81       	ldd	r31, Z+2	; 0x02
 c96:	e0 2d       	mov	r30, r0
 c98:	86 81       	ldd	r24, Z+6	; 0x06
 c9a:	97 81       	ldd	r25, Z+7	; 0x07
 c9c:	90 93 50 07 	sts	0x0750, r25
 ca0:	80 93 4f 07 	sts	0x074F, r24
 ca4:	08 95       	ret

00000ca6 <memset>:
 ca6:	dc 01       	movw	r26, r24
 ca8:	01 c0       	rjmp	.+2      	; 0xcac <memset+0x6>
 caa:	6d 93       	st	X+, r22
 cac:	41 50       	subi	r20, 0x01	; 1
 cae:	50 40       	sbci	r21, 0x00	; 0
 cb0:	e0 f7       	brcc	.-8      	; 0xcaa <memset+0x4>
 cb2:	08 95       	ret

00000cb4 <strncpy>:
 cb4:	fb 01       	movw	r30, r22
 cb6:	dc 01       	movw	r26, r24
 cb8:	41 50       	subi	r20, 0x01	; 1
 cba:	50 40       	sbci	r21, 0x00	; 0
 cbc:	48 f0       	brcs	.+18     	; 0xcd0 <strncpy+0x1c>
 cbe:	01 90       	ld	r0, Z+
 cc0:	0d 92       	st	X+, r0
 cc2:	00 20       	and	r0, r0
 cc4:	c9 f7       	brne	.-14     	; 0xcb8 <strncpy+0x4>
 cc6:	01 c0       	rjmp	.+2      	; 0xcca <strncpy+0x16>
 cc8:	1d 92       	st	X+, r1
 cca:	41 50       	subi	r20, 0x01	; 1
 ccc:	50 40       	sbci	r21, 0x00	; 0
 cce:	e0 f7       	brcc	.-8      	; 0xcc8 <strncpy+0x14>
 cd0:	08 95       	ret

00000cd2 <_exit>:
 cd2:	f8 94       	cli

00000cd4 <__stop_program>:
 cd4:	ff cf       	rjmp	.-2      	; 0xcd4 <__stop_program>
